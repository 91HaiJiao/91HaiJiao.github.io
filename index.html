<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Cyber Runner: Final Fix</title>
    <style>
        body { margin: 0; overflow: hidden; background: #0f172a; font-family: 'Segoe UI', sans-serif; user-select: none; }
        #game-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
        
        /* UI 界面样式 */
        .ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; display: flex; flex-direction: column; justify-content: space-between;
        }
        .top-bar {
            padding: 20px; display: flex; justify-content: space-between; align-items: flex-start;
            background: linear-gradient(to bottom, rgba(0,0,0,0.8), transparent);
        }
        .stat-group { color: white; text-shadow: 0 2px 4px rgba(0,0,0,0.8); }
        .label { font-size: 12px; color: #aaa; letter-spacing: 1px; font-weight: bold; }
        .value { font-size: 32px; font-weight: 800; font-family: monospace; }
        #hp-value { color: #ef4444; }
        #score-value { color: #fbbf24; }
        
        /* Buff 状态栏 */
        #buff-bar {
            display: flex; gap: 10px; margin-top: 10px;
        }
        .buff {
            background: rgba(0,0,0,0.5); padding: 5px 10px; border-radius: 4px;
            font-size: 14px; font-weight: bold; color: white; display: none;
            border: 1px solid rgba(255,255,255,0.3);
            box-shadow: 0 0 10px rgba(255,255,255,0.1);
        }

        /* 菜单遮罩 */
        #overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(15, 23, 42, 0.95);
            display: flex; flex-direction: column;
            align-items: center; justify-content: center;
            z-index: 20; pointer-events: auto;
            transition: opacity 0.3s;
            backdrop-filter: blur(5px);
        }
        #overlay.hidden { opacity: 0; pointer-events: none; }
        
        h1 {
            color: #34d399; font-size: 64px; margin: 0 0 10px 0;
            text-transform: uppercase; font-style: italic;
            text-shadow: 0 0 30px rgba(52, 211, 153, 0.4);
            letter-spacing: -2px;
        }
        
        .mode-select {
            display: flex; gap: 15px; margin-top: 30px; flex-wrap: wrap; justify-content: center;
        }
        
        button {
            background: linear-gradient(145deg, #1f2937, #111827);
            border: 1px solid #374151;
            padding: 20px 30px; color: white;
            font-size: 18px; font-weight: bold; border-radius: 12px;
            cursor: pointer; transition: all 0.2s;
            min-width: 140px;
            pointer-events: auto;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.5);
        }
        button:hover { border-color: #34d399; color: #34d399; transform: translateY(-3px); box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.5); }
        button:active { transform: scale(0.98); }
        
        button.god-mode { border-color: #f59e0b; color: #f59e0b; }
        button.god-mode:hover { background: #f59e0b; color: #000; }

        .subtitle { color: #9ca3af; margin-bottom: 40px; font-size: 16px; max-width: 400px; text-align: center; line-height: 1.5; }
    </style>
</head>
<body>

    <div id="game-container"></div>

    <div class="ui-layer">
        <div class="top-bar">
            <div class="stat-group">
                <div class="label">ARMOR / HP</div>
                <div class="value" id="hp-value">100</div>
                <div id="buff-bar">
                    <div id="buff-shield" class="buff" style="color:#60a5fa; border-color:#60a5fa">SHIELD</div>
                    <div id="buff-magnet" class="buff" style="color:#fbbf24; border-color:#fbbf24">MAGNET</div>
                </div>
            </div>
            <div class="stat-group" style="text-align: right;">
                <div class="label">SCORE</div>
                <div class="value" id="score-value">00000</div>
                <div class="label" style="margin-top:5px; font-size:10px; opacity:0.7">BEST: <span id="best-score">0</span></div>
            </div>
        </div>
    </div>

    <div id="overlay">
        <h1 id="title-text">CYBER RUN</h1>
        <div class="subtitle" id="msg-text">SYSTEM ONLINE<br>INITIALIZE ARMOR PROTOCOL</div>
        
        <div class="mode-select" id="start-menu">
            <button onclick="startGame(100)">标准<br><span style="font-size:12px; color:#aaa; font-weight:normal">100 HP</span></button>
            <button onclick="startGame(200)">强化<br><span style="font-size:12px; color:#aaa; font-weight:normal">200 HP</span></button>
            <button onclick="startGame(1000)">重装<br><span style="font-size:12px; color:#aaa; font-weight:normal">1000 HP</span></button>
            <button class="god-mode" onclick="startGame(999999)">GOD<br><span style="font-size:12px; font-weight:normal">DEV MODE</span></button>
        </div>
        
        <div class="mode-select hidden" id="restart-menu">
            <button onclick="showStartMenu()">主菜单</button>
            <button onclick="restartLastMode()" style="border-color:#34d399; color:#34d399">再次尝试</button>
        </div>
    </div>

    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // ==========================================
        // 1. 全局配置
        // ==========================================
        const CONFIG = {
            laneWidth: 3.5,
            chunkSize: 40,
            chunkCount: 15,
            fogStart: 30, // 增加雾效可视距离
            fogEnd: 110,
            colors: {
                sky: 0x0f172a,
                ground: 0x1e293b,
                hero: 0xec4899,
                obstacleLow: 0xdc2626,
                obstacleHigh: 0x475569,
                coin: 0xf59e0b,
                magnet: 0x3b82f6,
                shield: 0x10b981
            },
            physics: {
                speedBase: 30,
                speedMax: 70,
                jumpForce: 18,
                gravity: -45,
                laneSpeed: 15
            }
        };

        window.startGame = (hp) => gameInstance.start(hp);
        window.showStartMenu = () => gameInstance.showMenu();
        window.restartLastMode = () => gameInstance.start(gameInstance.lastHpMode);

        // ==========================================
        // 2. 角色类 (Hero)
        // ==========================================
        class Hero {
            constructor(scene) {
                this.scene = scene;
                this.mesh = new THREE.Group();
                this.lane = 0; this.targetX = 0;
                this.velocityY = 0;
                this.isJumping = false; this.isDucking = false; this.isDead = false;
                this.runTime = 0; this.duckTimer = 0; this.flashTimer = 0;
                
                this.initModel();
                this.scene.add(this.mesh);
            }

            initModel() {
                this.matBody = new THREE.MeshPhongMaterial({ color: CONFIG.colors.hero, flatShading: true });
                this.matFlash = new THREE.MeshBasicMaterial({ color: 0xffffff }); 

                this.bodyGroup = new THREE.Group();
                this.mesh.add(this.bodyGroup);

                // 身体部件
                this.torso = new THREE.Mesh(new THREE.BoxGeometry(0.8, 1.0, 0.5), this.matBody);
                this.torso.position.y = 1.5;
                this.torso.castShadow = true;
                this.bodyGroup.add(this.torso);

                const head = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.6, 0.6), this.matBody);
                head.position.y = 0.9; head.castShadow = true;
                this.torso.add(head);

                const jetpack = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.8, 0.3), new THREE.MeshPhongMaterial({color: 0x333333}));
                jetpack.position.set(0, 0, 0.3);
                this.torso.add(jetpack);

                const limbGeo = new THREE.BoxGeometry(0.25, 0.9, 0.25);
                limbGeo.translate(0, -0.4, 0);
                const mkLimb = (x, y) => {
                    const m = new THREE.Mesh(limbGeo, this.matBody);
                    m.position.set(x, y, 0); m.castShadow = true;
                    return m;
                }
                this.armL = mkLimb(-0.55, 0.4); this.armR = mkLimb(0.55, 0.4);
                this.legL = mkLimb(-0.25, -0.5); this.legR = mkLimb(0.25, -0.5);
                this.torso.add(this.armL, this.armR, this.legL, this.legR);

                // 护盾视觉
                this.shieldMesh = new THREE.Mesh(
                    new THREE.SphereGeometry(1.3, 16, 16),
                    new THREE.MeshBasicMaterial({ color: CONFIG.colors.shield, transparent: true, opacity: 0.2, wireframe: true })
                );
                this.shieldMesh.position.y = 1.5;
                this.shieldMesh.visible = false;
                this.mesh.add(this.shieldMesh);
            }

            reset() {
                this.lane = 0; this.targetX = 0;
                this.mesh.position.set(0, 0, 0);
                this.velocityY = 0;
                this.isJumping = false; this.isDucking = false; this.isDead = false;
                this.flashTimer = 0;
                this.setShield(false);
                this.mesh.visible = true;
                this.mesh.rotation.x = 0;
            }

            update(delta, speed) {
                if (this.isDead) return;

                // 左右移动插值
                this.mesh.position.x = THREE.MathUtils.lerp(this.mesh.position.x, this.targetX, CONFIG.physics.laneSpeed * delta);
                // 倾斜效果
                this.mesh.rotation.z = (this.mesh.position.x - this.targetX) * 0.1;

                // 跳跃物理
                this.velocityY += CONFIG.physics.gravity * delta;
                this.mesh.position.y += this.velocityY * delta;
                if (this.mesh.position.y <= 0) {
                    this.mesh.position.y = 0; this.velocityY = 0; this.isJumping = false;
                }

                // 动画
                this.runTime += delta * speed * 0.6;
                this.animateBody(delta);

                // 受伤闪烁
                if (this.flashTimer > 0) {
                    this.flashTimer -= delta;
                    const useFlash = Math.floor(this.flashTimer * 10) % 2 === 0;
                    this.overrideMaterial(useFlash ? this.matFlash : null);
                } else {
                    this.overrideMaterial(null);
                }

                // 护盾旋转
                if (this.shieldMesh.visible) {
                    this.shieldMesh.rotation.y += delta * 2;
                    this.shieldMesh.position.y = this.torso.position.y;
                }
            }

            animateBody(delta) {
                if (this.isJumping) {
                    // 跳跃姿态
                    this.armL.rotation.x = -2.5; this.armR.rotation.x = -2.5;
                    this.legL.rotation.x = -0.5; this.legR.rotation.x = -0.8;
                } else if (this.isDucking) {
                    // 下蹲姿态
                    this.torso.position.y = THREE.MathUtils.lerp(this.torso.position.y, 0.6, 15*delta);
                    this.torso.rotation.x = -Math.PI / 2.2;
                    this.armL.rotation.x = 0; this.armR.rotation.x = 0;
                    this.legL.rotation.x = 0; this.legR.rotation.x = 0;
                    if ((this.duckTimer -= delta) <= 0) this.isDucking = false;
                } else {
                    // 跑步姿态
                    this.torso.position.y = THREE.MathUtils.lerp(this.torso.position.y, 1.5, 5*delta);
                    this.torso.rotation.x = 0.2;
                    const s = Math.sin(this.runTime);
                    this.armL.rotation.x = s; this.armR.rotation.x = -s;
                    this.legL.rotation.x = -s; this.legR.rotation.x = s;
                }
            }

            overrideMaterial(mat) {
                this.torso.material = mat || this.matBody;
                this.armL.material = mat || this.matBody;
                this.armR.material = mat || this.matBody;
                this.legL.material = mat || this.matBody;
                this.legR.material = mat || this.matBody;
            }

            setShield(active) { this.shieldMesh.visible = active; }
            takeDamage() { this.flashTimer = 1.0; }
            changeLane(dir) { if(!this.isDead) { const next = this.lane + dir; if(next >= -1 && next <= 1) { this.lane = next; this.targetX = this.lane * CONFIG.laneWidth; } } }
            jump() { if(!this.isJumping && !this.isDead) { this.isJumping = true; this.isDucking = false; this.velocityY = CONFIG.physics.jumpForce; } }
            duck() { if(!this.isJumping && !this.isDead) { this.isDucking = true; this.duckTimer = 0.8; this.velocityY = -15; } }
            
            getHitbox() {
                const h = this.isDucking ? 0.6 : 1.6;
                const pos = this.mesh.position;
                return new THREE.Box3().setFromCenterAndSize(
                    new THREE.Vector3(pos.x, pos.y + h/2, pos.z),
                    new THREE.Vector3(0.5, h, 0.5)
                );
            }
        }

        // ==========================================
        // 3. 地图管理器 (World)
        // ==========================================
        class WorldManager {
            constructor(scene) {
                this.scene = scene;
                this.groundChunks = [];
                this.objects = []; 
                
                // 资源缓存
                this.geoGround = new THREE.PlaneGeometry(12, CONFIG.chunkSize);
                this.geoObsHigh = new THREE.BoxGeometry(2.8, 3.0, 1.0);
                this.geoObsLow = new THREE.BoxGeometry(2.8, 0.9, 0.5);
                this.geoCoin = new THREE.CylinderGeometry(0.4, 0.4, 0.1, 8);
                this.geoMagnet = new THREE.TorusGeometry(0.5, 0.15, 8, 16);
                this.geoShield = new THREE.IcosahedronGeometry(0.6); 

                this.matGround = new THREE.MeshStandardMaterial({ color: CONFIG.colors.ground, roughness: 0.8 });
                this.matObsHigh = new THREE.MeshStandardMaterial({ color: CONFIG.colors.obstacleHigh, emissive: 0x111111 });
                this.matObsLow = new THREE.MeshStandardMaterial({ color: CONFIG.colors.obstacleLow, emissive: 0x330000 });
                this.matCoin = new THREE.MeshPhongMaterial({ color: CONFIG.colors.coin, shininess: 100, emissive: 0x221100 });
                this.matMagnet = new THREE.MeshPhongMaterial({ color: CONFIG.colors.magnet, emissive: 0x1111ff });
                this.matShield = new THREE.MeshPhongMaterial({ color: CONFIG.colors.shield, emissive: 0x11ff11 });

                this.initGround();
            }

            initGround() {
                this.geoGround.rotateX(-Math.PI/2);
                this.geoCoin.rotateZ(Math.PI/2);
                this.geoMagnet.rotateY(Math.PI/2);

                for(let i=0; i<CONFIG.chunkCount; i++) {
                    const chunk = new THREE.Mesh(this.geoGround, this.matGround);
                    chunk.position.z = -i * CONFIG.chunkSize;
                    chunk.receiveShadow = true;
                    this.scene.add(chunk);
                    this.groundChunks.push(chunk);
                    if(i > 3) this.spawnChunkContent(chunk.position.z);
                }
            }

            reset() {
                this.objects.forEach(o => this.scene.remove(o.mesh));
                this.objects = [];
                for(let i=0; i<CONFIG.chunkCount; i++) {
                    this.groundChunks[i].position.z = -i * CONFIG.chunkSize;
                    if(i>3) this.spawnChunkContent(this.groundChunks[i].position.z);
                }
            }

            update(playerZ, magnetActive, playerPos) {
                // 地面循环逻辑
                const firstChunk = this.groundChunks[0];
                if (firstChunk.position.z > playerZ + CONFIG.chunkSize) {
                    let minZ = Infinity; // 修正：使用 Infinity 确保找到最小值
                    this.groundChunks.forEach(c => minZ = Math.min(minZ, c.position.z));
                    
                    firstChunk.position.z = minZ - CONFIG.chunkSize;
                    this.groundChunks.push(this.groundChunks.shift()); // 移动到数组末尾
                    this.spawnChunkContent(firstChunk.position.z);
                }

                // 物体清理与动画
                for (let i = this.objects.length - 1; i >= 0; i--) {
                    const obj = this.objects[i];
                    
                    if (obj.mesh.position.z > playerZ + 20) {
                        this.scene.remove(obj.mesh);
                        this.objects.splice(i, 1);
                        continue;
                    }

                    if (obj.type === 'coin') {
                        obj.mesh.rotation.x += 0.05;
                        if (magnetActive && obj.mesh.position.distanceTo(playerPos) < 18) {
                            obj.mesh.position.lerp(playerPos, 0.25);
                        }
                    } else if (obj.type === 'magnet' || obj.type === 'shield') {
                        obj.mesh.rotation.y += 0.05;
                        obj.mesh.position.y = 1 + Math.sin(Date.now()*0.005)*0.2;
                    }
                }
            }

            spawnChunkContent(zBase) {
                const segments = [0, -CONFIG.chunkSize/3, -CONFIG.chunkSize*2/3];
                segments.forEach(offset => {
                    const z = zBase + offset;
                    const rand = Math.random();
                    if (rand < 0.15) this.spawnItem(z);
                    else if (rand < 0.5) this.spawnCoinPattern(z);
                    else this.spawnObstacles(z);
                });
            }

            spawnItem(z) {
                const lane = Math.floor(Math.random()*3) - 1;
                const type = Math.random() > 0.5 ? 'magnet' : 'shield';
                const mesh = new THREE.Mesh(type === 'magnet' ? this.geoMagnet : this.geoShield, type === 'magnet' ? this.matMagnet : this.matShield);
                mesh.position.set(lane * CONFIG.laneWidth, 1, z);
                this.scene.add(mesh);
                this.objects.push({ mesh, type, active: true });
            }

            spawnCoinPattern(z) {
                const pattern = Math.floor(Math.random() * 3);
                const lane = Math.floor(Math.random()*3) - 1;
                const x = lane * CONFIG.laneWidth;
                if (pattern === 0) {
                    for(let k=0; k<5; k++) this.createCoin(x, 1, z - k*2);
                } else if (pattern === 1) {
                    this.createCoin(x, 1, z); this.createCoin(x, 2, z-2); this.createCoin(x, 2, z-4); this.createCoin(x, 1, z-6);
                } else {
                    this.createCoin(-CONFIG.laneWidth, 1, z); this.createCoin(0, 1, z); this.createCoin(CONFIG.laneWidth, 1, z);
                }
            }

            createCoin(x, y, z) {
                const mesh = new THREE.Mesh(this.geoCoin, this.matCoin);
                mesh.position.set(x, y, z);
                this.scene.add(mesh);
                this.objects.push({ mesh, type: 'coin', active: true });
            }

            spawnObstacles(z) {
                const lanes = [-1, 0, 1].sort(()=>Math.random()-0.5);
                const count = Math.random() > 0.6 ? 2 : 1; 
                for(let i=0; i<count; i++) {
                    const lane = lanes[i];
                    const isHigh = Math.random() > 0.5;
                    const mesh = new THREE.Mesh(isHigh ? this.geoObsHigh : this.geoObsLow, isHigh ? this.matObsHigh : this.matObsLow);
                    const h = isHigh ? 3.0 : 0.9;
                    mesh.position.set(lane * CONFIG.laneWidth, h/2, z);
                    mesh.castShadow = true;
                    this.scene.add(mesh);
                    this.objects.push({ mesh, type: 'obstacle', active: true, box: new THREE.Vector3(2.5, h, 1) });
                }
            }

            checkCollisions(hero, callbacks) {
                const heroBox = hero.getHitbox();
                for (let i = 0; i < this.objects.length; i++) {
                    const obj = this.objects[i];
                    if (!obj.active || Math.abs(obj.mesh.position.z - hero.mesh.position.z) > 3) continue;

                    let hit = false;
                    if (['coin','magnet','shield'].includes(obj.type)) {
                        if (obj.mesh.position.distanceTo(hero.mesh.position) < 1.5) hit = true;
                    } else {
                        const obsBox = new THREE.Box3().setFromCenterAndSize(obj.mesh.position, obj.box);
                        if (heroBox.intersectsBox(obsBox)) hit = true;
                    }
                    if (hit) callbacks.onHit(obj, i);
                }
            }
        }

        // ==========================================
        // 4. 特效 & 游戏主控 (修复了 Shaker)
        // ==========================================
        class ScreenShaker {
            constructor() { 
                this.shake = 0; 
                this.offset = new THREE.Vector3(); // 存储偏移量，而不是修改摄像机
            }
            trigger(val) { this.shake = val; }
            update(delta) {
                if(this.shake > 0) {
                    this.offset.set(
                        (Math.random()-0.5) * this.shake,
                        (Math.random()-0.5) * this.shake,
                        0
                    );
                    this.shake = Math.max(0, this.shake - delta*2);
                } else {
                    this.offset.set(0, 0, 0);
                }
            }
        }

        class ParticleSystem {
            constructor(scene) { this.scene = scene; this.pool = []; }
            spawn(pos, color, count=10) {
                const geo = new THREE.BoxGeometry(0.25, 0.25, 0.25);
                const mat = new THREE.MeshBasicMaterial({ color: color });
                for(let i=0; i<count; i++) {
                    const p = new THREE.Mesh(geo, mat);
                    p.position.copy(pos);
                    p.vel = new THREE.Vector3((Math.random()-0.5)*15, Math.random()*15, (Math.random()-0.5)*15);
                    p.life = 1.0;
                    this.scene.add(p);
                    this.pool.push(p);
                }
            }
            update(delta) {
                for(let i=this.pool.length-1; i>=0; i--) {
                    const p = this.pool[i];
                    p.position.addScaledVector(p.vel, delta);
                    p.vel.y -= 40 * delta; 
                    p.life -= delta * 1.5;
                    p.scale.setScalar(p.life);
                    p.rotation.x += delta*10;
                    if(p.life <= 0) { this.scene.remove(p); this.pool.splice(i, 1); }
                }
            }
        }

        class Game {
            constructor() {
                this.initThree();
                this.hero = new Hero(this.scene);
                this.world = new WorldManager(this.scene);
                this.particles = new ParticleSystem(this.scene);
                this.shaker = new ScreenShaker(); // 不再传递 camera

                this.state = 'MENU';
                this.hp = 0; this.score = 0; this.highScore = localStorage.getItem('cyber_highscore') || 0;
                this.speed = 0; this.magnetTimer = 0; this.hasShield = false;
                
                this.ui = {
                    hp: document.getElementById('hp-value'),
                    score: document.getElementById('score-value'),
                    best: document.getElementById('best-score'),
                    overlay: document.getElementById('overlay'),
                    title: document.getElementById('title-text'),
                    msg: document.getElementById('msg-text'),
                    menuStart: document.getElementById('start-menu'),
                    menuRestart: document.getElementById('restart-menu'),
                    buffShield: document.getElementById('buff-shield'),
                    buffMagnet: document.getElementById('buff-magnet')
                };
                this.ui.best.innerText = this.highScore;
                this.setupInputs();
                this.animate();
            }

            initThree() {
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(CONFIG.colors.sky);
                // 调整雾效范围，防止跑快了看不到远处
                this.scene.fog = new THREE.Fog(CONFIG.colors.sky, CONFIG.fogStart, CONFIG.fogEnd);
                
                this.camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 200);
                // 初始位置
                this.camera.position.set(0, 5, 10);
                
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                document.getElementById('game-container').appendChild(this.renderer.domElement);

                const ambi = new THREE.HemisphereLight(0xffffff, 0x000000, 0.7);
                this.scene.add(ambi);
                this.sun = new THREE.DirectionalLight(0xffffff, 1.2);
                this.sun.position.set(20, 50, 20);
                this.sun.castShadow = true;
                this.sun.shadow.mapSize.set(2048, 2048);
                this.sun.shadow.camera.top = 50; this.sun.shadow.camera.bottom = -50;
                this.sun.shadow.camera.left = -30; this.sun.shadow.camera.right = 30;
                this.scene.add(this.sun);
                
                window.addEventListener('resize', ()=> {
                    this.camera.aspect = window.innerWidth/window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });
            }

            showMenu() {
                this.state = 'MENU';
                this.ui.overlay.classList.remove('hidden');
                this.ui.title.innerText = "CYBER RUN";
                this.ui.msg.innerHTML = "SYSTEM ONLINE<br>INITIALIZE ARMOR PROTOCOL";
                this.ui.menuStart.classList.remove('hidden');
                this.ui.menuRestart.classList.add('hidden');
            }

            start(hpMode) {
                this.state = 'PLAYING';
                this.lastHpMode = hpMode;
                this.hp = hpMode;
                this.score = 0;
                this.speed = CONFIG.physics.speedBase;
                this.magnetTimer = 0;
                this.hasShield = false;
                this.hero.reset();
                this.world.reset();
                this.updateUI();
                this.ui.overlay.classList.add('hidden');
            }

            gameOver() {
                this.state = 'GAMEOVER';
                this.hero.isDead = true;
                this.hero.mesh.rotation.x = -Math.PI/2;
                this.hero.mesh.position.y = 0.5;
                this.shaker.trigger(0.5);
                if (this.score > this.highScore) {
                    this.highScore = Math.floor(this.score);
                    localStorage.setItem('cyber_highscore', this.highScore);
                    this.ui.best.innerText = this.highScore;
                }
                setTimeout(() => {
                    this.ui.overlay.classList.remove('hidden');
                    this.ui.title.innerText = "CRITICAL FAILURE";
                    this.ui.msg.innerText = `最终得分: ${Math.floor(this.score)}`;
                    this.ui.menuStart.classList.add('hidden');
                    this.ui.menuRestart.classList.remove('hidden');
                }, 1000);
            }

            update(delta) {
                if (this.state !== 'PLAYING') return;

                // 速度随时间增加
                if (this.speed < CONFIG.physics.speedMax) this.speed += delta * 0.5;
                const moveDist = this.speed * delta;
                this.hero.mesh.position.z -= moveDist;

                if (this.magnetTimer > 0) this.magnetTimer -= delta;

                this.hero.update(delta, this.speed);
                this.world.update(this.hero.mesh.position.z, this.magnetTimer > 0, this.hero.mesh.position);
                this.particles.update(delta);
                this.shaker.update(delta);

                this.world.checkCollisions(this.hero, {
                    onHit: (obj, index) => this.handleCollision(obj, index)
                });

                this.score += moveDist * 0.1;
                this.updateUI();

                // ==========================================
                // 关键修复：摄像机逻辑
                // ==========================================
                // 1. 计算理想位置
                const targetZ = this.hero.mesh.position.z + 10;
                const targetX = this.hero.mesh.position.x * 0.6;
                const baseY = 5; 

                // 2. 应用平滑移动 + 震动偏移 (绝对位置赋值，消除累积误差)
                this.camera.position.x = THREE.MathUtils.lerp(this.camera.position.x, targetX, 5 * delta) + this.shaker.offset.x;
                this.camera.position.y = baseY + this.shaker.offset.y;
                this.camera.position.z = targetZ;

                // 3. 强制锁定视角中心 (防止视角漂移)
                // 让摄像机始终看向前方地面上的一个点
                this.camera.lookAt(
                    this.camera.position.x * 0.5, // 稍微看向弯道内侧
                    2, 
                    this.camera.position.z - 20
                );
                
                // 灯光跟随
                this.sun.position.z = this.hero.mesh.position.z + 20;
                this.sun.target.position.z = this.hero.mesh.position.z;
                this.sun.target.updateMatrixWorld();
            }

            handleCollision(obj, index) {
                obj.active = false;
                this.scene.remove(obj.mesh);

                if (obj.type === 'coin') {
                    this.score += 50;
                    this.particles.spawn(obj.mesh.position, CONFIG.colors.coin, 5);
                } 
                else if (obj.type === 'magnet') {
                    this.magnetTimer = 10;
                    this.particles.spawn(obj.mesh.position, CONFIG.colors.magnet, 15);
                } 
                else if (obj.type === 'shield') {
                    this.hasShield = true;
                    this.hero.setShield(true);
                    this.particles.spawn(obj.mesh.position, CONFIG.colors.shield, 15);
                }
                else if (obj.type === 'obstacle') {
                    if (this.hasShield) {
                        this.hasShield = false;
                        this.hero.setShield(false);
                        this.particles.spawn(obj.mesh.position, 0x88ccff, 20);
                        this.shaker.trigger(0.5);
                    } else {
                        if (this.hp <= 9999) this.hp--;
                        this.particles.spawn(obj.mesh.position, 0xff0000, 20);
                        this.shaker.trigger(1.2); // 撞击震动
                        this.hero.takeDamage();
                        if (this.hp <= 0) this.gameOver();
                    }
                }
            }

            updateUI() {
                this.ui.score.innerText = Math.floor(this.score).toString().padStart(6, '0');
                this.ui.hp.innerText = (this.hp > 9999) ? "INF" : this.hp;
                this.ui.buffMagnet.style.display = this.magnetTimer > 0 ? 'block' : 'none';
                this.ui.buffShield.style.display = this.hasShield ? 'block' : 'none';
                if (this.magnetTimer > 0) this.ui.buffMagnet.innerText = `MAGNET ${Math.ceil(this.magnetTimer)}s`;
            }

            animate() {
                requestAnimationFrame(() => this.animate());
                const delta = Math.min(this.clock.getDelta(), 0.1);
                this.update(delta);
                this.renderer.render(this.scene, this.camera);
            }

            setupInputs() {
                this.clock = new THREE.Clock();
                const handleDir = (dir) => this.hero.changeLane(dir);
                document.addEventListener('keydown', (e) => {
                    if (this.state !== 'PLAYING') return;
                    if (e.key === 'ArrowLeft' || e.key === 'a') handleDir(-1);
                    if (e.key === 'ArrowRight' || e.key === 'd') handleDir(1);
                    if (e.key === 'ArrowUp' || e.key === 'w' || e.key === ' ') this.hero.jump();
                    if (e.key === 'ArrowDown' || e.key === 's') this.hero.duck();
                });
                let sx=0, sy=0;
                document.addEventListener('touchstart', e => { sx = e.touches[0].clientX; sy = e.touches[0].clientY; }, {passive: false});
                document.addEventListener('touchend', e => {
                    if (this.state !== 'PLAYING') return;
                    const dx = e.changedTouches[0].clientX - sx;
                    const dy = e.changedTouches[0].clientY - sy;
                    if (Math.abs(dx) > Math.abs(dy)) {
                        if (Math.abs(dx) > 30) handleDir(dx > 0 ? 1 : -1);
                    } else {
                        if (Math.abs(dy) > 30) { dy < 0 ? this.hero.jump() : this.hero.duck(); }
                    }
                }, {passive: false});
                // 防止移动端滚动
                document.addEventListener('touchmove', e => e.preventDefault(), {passive: false});
            }
        }

        const gameInstance = new Game();
    </script>
</body>
</html>
