<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Cyber Runner: Neon Overdrive</title>
    <style>
        /* CSS 背景改为明亮的渐变，防止加载时黑屏 */
        body { margin: 0; overflow: hidden; background: linear-gradient(to bottom, #240046, #10002b); font-family: 'Segoe UI', sans-serif; user-select: none; }
        #game-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
        
        /* UI 界面样式 - 增强对比度 */
        .ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; display: flex; flex-direction: column; justify-content: space-between;
        }
        .top-bar {
            padding: 20px; display: flex; justify-content: space-between; align-items: flex-start;
            background: linear-gradient(to bottom, rgba(36, 0, 70, 0.9), transparent);
        }
        .stat-group { color: white; text-shadow: 0 0 10px rgba(255,255,255,0.5); }
        .label { font-size: 12px; color: #d8b4fe; letter-spacing: 1px; font-weight: bold; text-transform: uppercase; }
        .value { font-size: 32px; font-weight: 800; font-family: monospace; filter: drop-shadow(0 0 5px currentColor); }
        #hp-value { color: #ff0055; }
        #score-value { color: #00f2ff; }
        
        /* Buff 状态栏 */
        #buff-bar { display: flex; gap: 10px; margin-top: 10px; }
        .buff {
            background: rgba(0,0,0,0.6); padding: 5px 12px; border-radius: 4px;
            font-size: 14px; font-weight: bold; color: white; display: none;
            border: 1px solid rgba(255,255,255,0.5);
            box-shadow: 0 0 15px rgba(255,255,255,0.2);
            text-shadow: 0 0 5px currentColor;
        }

        /* 菜单遮罩 */
        #overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(16, 0, 43, 0.85); /* 半透明紫背景 */
            display: flex; flex-direction: column;
            align-items: center; justify-content: center;
            z-index: 20; pointer-events: auto;
            transition: opacity 0.3s;
            backdrop-filter: blur(8px);
        }
        #overlay.hidden { opacity: 0; pointer-events: none; }
        
        h1 {
            color: #00f2ff; font-size: 64px; margin: 0 0 10px 0;
            text-transform: uppercase; font-style: italic;
            text-shadow: 0 0 40px rgba(0, 242, 255, 0.6), 4px 4px 0px #ff0055;
            letter-spacing: -2px;
        }
        
        .mode-select {
            display: flex; gap: 15px; margin-top: 30px; flex-wrap: wrap; justify-content: center;
        }
        
        button {
            background: linear-gradient(135deg, #3c096c, #240046);
            border: 1px solid #7b2cbf;
            padding: 20px 30px; color: white;
            font-size: 18px; font-weight: bold; border-radius: 8px;
            cursor: pointer; transition: all 0.2s;
            min-width: 140px; pointer-events: auto;
            box-shadow: 0 0 20px rgba(123, 44, 191, 0.3);
            text-shadow: 0 0 5px rgba(255,255,255,0.5);
        }
        button:hover { 
            border-color: #00f2ff; color: #00f2ff; 
            transform: translateY(-5px); 
            box-shadow: 0 0 30px rgba(0, 242, 255, 0.4);
            background: #5a189a;
        }
        button:active { transform: scale(0.98); }
        
        button.god-mode { border-color: #ff9e00; color: #ff9e00; }
        button.god-mode:hover { background: #ff9e00; color: #000; text-shadow: none; }

        .subtitle { color: #e0aaff; margin-bottom: 40px; font-size: 16px; max-width: 400px; text-align: center; line-height: 1.5; font-weight: 500; }
    </style>
</head>
<body>

    <div id="game-container"></div>

    <div class="ui-layer">
        <div class="top-bar">
            <div class="stat-group">
                <div class="label">ARMOR</div>
                <div class="value" id="hp-value">100</div>
                <div id="buff-bar">
                    <div id="buff-shield" class="buff" style="color:#00f2ff; border-color:#00f2ff">SHIELD</div>
                    <div id="buff-magnet" class="buff" style="color:#ff9e00; border-color:#ff9e00">MAGNET</div>
                </div>
            </div>
            <div class="stat-group" style="text-align: right;">
                <div class="label">SCORE</div>
                <div class="value" id="score-value">00000</div>
                <div class="label" style="margin-top:5px; font-size:10px; opacity:0.8">BEST: <span id="best-score">0</span></div>
            </div>
        </div>
    </div>

    <div id="overlay">
        <h1 id="title-text">CYBER RUN</h1>
        <div class="subtitle" id="msg-text">NEON OVERDRIVE<br>SYSTEM READY</div>
        
        <div class="mode-select" id="start-menu">
            <button onclick="startGame(100)">标准<br><span style="font-size:12px; opacity:0.7; font-weight:normal">100 HP</span></button>
            <button onclick="startGame(200)">强化<br><span style="font-size:12px; opacity:0.7; font-weight:normal">200 HP</span></button>
            <button onclick="startGame(1000)">重装<br><span style="font-size:12px; opacity:0.7; font-weight:normal">1000 HP</span></button>
            <button class="god-mode" onclick="startGame(999999)">GOD<br><span style="font-size:12px; font-weight:normal">无敌模式</span></button>
        </div>
        
        <div class="mode-select hidden" id="restart-menu">
            <button onclick="showStartMenu()">主菜单</button>
            <button onclick="restartLastMode()" style="border-color:#00f2ff; color:#00f2ff; background:#1e1b4b">立即重试</button>
        </div>
    </div>

    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // ==========================================
        // 1. 全局配置 (高亮配色版)
        // ==========================================
        const CONFIG = {
            laneWidth: 3.5,
            chunkSize: 40,
            chunkCount: 15,
            fogStart: 40,
            fogEnd: 120, // 增加可视距离
            colors: {
                // 核心改动：高饱和度紫/青配色
                sky: 0x240046,      // 深紫罗兰背景
                fog: 0x3c096c,      // 亮紫色雾气
                ground: 0x10002b,   // 深紫色地面
                grid: 0x00f2ff,     // 青色网格线
                
                hero: 0xff0055,     // 亮粉色主角
                heroEmissive: 0x550022,
                
                obstacleHigh: 0xff3333, // 亮红高墙
                obstacleLow: 0xff9900,  // 亮橙矮墙
                
                coin: 0xffd60a,     // 金黄硬币
                magnet: 0x3a86ff,   // 亮蓝磁铁
                shield: 0x00f2ff    // 青色护盾
            },
            physics: {
                speedBase: 30,
                speedMax: 75,
                jumpForce: 18,
                gravity: -45,
                laneSpeed: 15
            }
        };

        window.startGame = (hp) => gameInstance.start(hp);
        window.showStartMenu = () => gameInstance.showMenu();
        window.restartLastMode = () => gameInstance.start(gameInstance.lastHpMode);

        // ==========================================
        // 2. 角色类 (Hero) - 增加发光材质
        // ==========================================
        class Hero {
            constructor(scene) {
                this.scene = scene;
                this.mesh = new THREE.Group();
                this.lane = 0; this.targetX = 0;
                this.velocityY = 0;
                this.isJumping = false; this.isDucking = false; this.isDead = false;
                this.runTime = 0; this.duckTimer = 0; this.flashTimer = 0;
                
                this.initModel();
                this.scene.add(this.mesh);
            }

            initModel() {
                // 材质升级：StandardMaterial + Emissive (自发光)
                this.matBody = new THREE.MeshStandardMaterial({ 
                    color: CONFIG.colors.hero, 
                    roughness: 0.3, 
                    metalness: 0.5,
                    emissive: CONFIG.colors.heroEmissive,
                    emissiveIntensity: 0.5
                });
                this.matFlash = new THREE.MeshBasicMaterial({ color: 0xffffff }); 

                this.bodyGroup = new THREE.Group();
                this.mesh.add(this.bodyGroup);

                // 身体构造
                this.torso = new THREE.Mesh(new THREE.BoxGeometry(0.8, 1.0, 0.5), this.matBody);
                this.torso.position.y = 1.5;
                this.torso.castShadow = true;
                this.bodyGroup.add(this.torso);

                const head = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.6, 0.6), this.matBody);
                head.position.y = 0.9; head.castShadow = true;
                this.torso.add(head);

                // 喷气背包 (亮灰色)
                const jetpack = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.8, 0.3), new THREE.MeshStandardMaterial({color: 0x888888, roughness:0.2}));
                jetpack.position.set(0, 0, 0.3);
                this.torso.add(jetpack);

                const limbGeo = new THREE.BoxGeometry(0.25, 0.9, 0.25);
                limbGeo.translate(0, -0.4, 0);
                const mkLimb = (x, y) => {
                    const m = new THREE.Mesh(limbGeo, this.matBody);
                    m.position.set(x, y, 0); m.castShadow = true;
                    return m;
                }
                this.armL = mkLimb(-0.55, 0.4); this.armR = mkLimb(0.55, 0.4);
                this.legL = mkLimb(-0.25, -0.5); this.legR = mkLimb(0.25, -0.5);
                this.torso.add(this.armL, this.armR, this.legL, this.legR);

                // 护盾 (更亮)
                this.shieldMesh = new THREE.Mesh(
                    new THREE.SphereGeometry(1.3, 24, 24),
                    new THREE.MeshBasicMaterial({ color: CONFIG.colors.shield, transparent: true, opacity: 0.3, wireframe: true })
                );
                this.shieldMesh.position.y = 1.5;
                this.shieldMesh.visible = false;
                this.mesh.add(this.shieldMesh);
            }

            reset() {
                this.lane = 0; this.targetX = 0;
                this.mesh.position.set(0, 0, 0);
                this.velocityY = 0;
                this.isJumping = false; this.isDucking = false; this.isDead = false;
                this.flashTimer = 0;
                this.setShield(false);
                this.mesh.visible = true;
                this.mesh.rotation.x = 0;
            }

            update(delta, speed) {
                if (this.isDead) return;

                this.mesh.position.x = THREE.MathUtils.lerp(this.mesh.position.x, this.targetX, CONFIG.physics.laneSpeed * delta);
                this.mesh.rotation.z = (this.mesh.position.x - this.targetX) * 0.1;

                this.velocityY += CONFIG.physics.gravity * delta;
                this.mesh.position.y += this.velocityY * delta;
                if (this.mesh.position.y <= 0) {
                    this.mesh.position.y = 0; this.velocityY = 0; this.isJumping = false;
                }

                this.runTime += delta * speed * 0.6;
                this.animateBody(delta);

                if (this.flashTimer > 0) {
                    this.flashTimer -= delta;
                    const useFlash = Math.floor(this.flashTimer * 10) % 2 === 0;
                    this.overrideMaterial(useFlash ? this.matFlash : null);
                } else {
                    this.overrideMaterial(null);
                }

                if (this.shieldMesh.visible) {
                    this.shieldMesh.rotation.y += delta * 3;
                    this.shieldMesh.position.y = this.torso.position.y;
                }
            }

            animateBody(delta) {
                if (this.isJumping) {
                    this.armL.rotation.x = -2.5; this.armR.rotation.x = -2.5;
                    this.legL.rotation.x = -0.5; this.legR.rotation.x = -0.8;
                } else if (this.isDucking) {
                    this.torso.position.y = THREE.MathUtils.lerp(this.torso.position.y, 0.6, 15*delta);
                    this.torso.rotation.x = -Math.PI / 2.2;
                    this.armL.rotation.x = 0; this.armR.rotation.x = 0;
                    this.legL.rotation.x = 0; this.legR.rotation.x = 0;
                    if ((this.duckTimer -= delta) <= 0) this.isDucking = false;
                } else {
                    this.torso.position.y = THREE.MathUtils.lerp(this.torso.position.y, 1.5, 5*delta);
                    this.torso.rotation.x = 0.2;
                    const s = Math.sin(this.runTime);
                    this.armL.rotation.x = s; this.armR.rotation.x = -s;
                    this.legL.rotation.x = -s; this.legR.rotation.x = s;
                }
            }

            overrideMaterial(mat) {
                this.torso.material = mat || this.matBody;
                this.armL.material = mat || this.matBody;
                this.armR.material = mat || this.matBody;
                this.legL.material = mat || this.matBody;
                this.legR.material = mat || this.matBody;
            }

            setShield(active) { this.shieldMesh.visible = active; }
            takeDamage() { this.flashTimer = 1.0; }
            changeLane(dir) { if(!this.isDead) { const next = this.lane + dir; if(next >= -1 && next <= 1) { this.lane = next; this.targetX = this.lane * CONFIG.laneWidth; } } }
            jump() { if(!this.isJumping && !this.isDead) { this.isJumping = true; this.isDucking = false; this.velocityY = CONFIG.physics.jumpForce; } }
            duck() { if(!this.isJumping && !this.isDead) { this.isDucking = true; this.duckTimer = 0.8; this.velocityY = -15; } }
            
            getHitbox() {
                const h = this.isDucking ? 0.6 : 1.6;
                const pos = this.mesh.position;
                return new THREE.Box3().setFromCenterAndSize(
                    new THREE.Vector3(pos.x, pos.y + h/2, pos.z),
                    new THREE.Vector3(0.5, h, 0.5)
                );
            }
        }

        // ==========================================
        // 3. 地图管理器 (World) - 增加网格地面
        // ==========================================
        class WorldManager {
            constructor(scene) {
                this.scene = scene;
                this.groundChunks = [];
                this.objects = []; 
                
                // 资源缓存
                this.geoGround = new THREE.PlaneGeometry(30, CONFIG.chunkSize); // 地面更宽
                this.geoObsHigh = new THREE.BoxGeometry(2.8, 3.0, 1.0);
                this.geoObsLow = new THREE.BoxGeometry(2.8, 0.9, 0.5);
                this.geoCoin = new THREE.CylinderGeometry(0.4, 0.4, 0.1, 16); // 更圆
                this.geoMagnet = new THREE.TorusGeometry(0.5, 0.15, 8, 16);
                this.geoShield = new THREE.IcosahedronGeometry(0.6); 

                // 材质：全部增加 Emissive 确保高亮
                this.matGround = new THREE.MeshPhongMaterial({ 
                    color: CONFIG.colors.ground, 
                    shininess: 50,
                    specular: 0x444444
                });
                
                this.matObsHigh = new THREE.MeshStandardMaterial({ 
                    color: CONFIG.colors.obstacleHigh, 
                    emissive: 0xaa0000, 
                    emissiveIntensity: 0.4,
                    roughness: 0.2 
                });
                this.matObsLow = new THREE.MeshStandardMaterial({ 
                    color: CONFIG.colors.obstacleLow, 
                    emissive: 0xaa5500, 
                    emissiveIntensity: 0.4,
                    roughness: 0.2 
                });
                
                this.matCoin = new THREE.MeshPhongMaterial({ color: CONFIG.colors.coin, emissive: 0xaa8800, shininess: 100 });
                this.matMagnet = new THREE.MeshPhongMaterial({ color: CONFIG.colors.magnet, emissive: 0x0044aa, shininess: 100 });
                this.matShield = new THREE.MeshPhongMaterial({ color: CONFIG.colors.shield, emissive: 0x00aa99, shininess: 100 });

                this.initGround();
            }

            initGround() {
                this.geoGround.rotateX(-Math.PI/2);
                this.geoCoin.rotateZ(Math.PI/2);
                this.geoMagnet.rotateY(Math.PI/2);

                for(let i=0; i<CONFIG.chunkCount; i++) {
                    const chunkGroup = new THREE.Group();
                    
                    // 地面实体
                    const groundMesh = new THREE.Mesh(this.geoGround, this.matGround);
                    groundMesh.receiveShadow = true;
                    chunkGroup.add(groundMesh);

                    // 视觉网格 (GridHelper) - 增加速度感
                    // 创建一个与 Chunk 大小匹配的网格
                    const grid = new THREE.GridHelper(30, 10, CONFIG.colors.grid, 0x331155);
                    grid.position.y = 0.02; // 稍微浮起避免Z-fighting
                    grid.position.z = 0;
                    grid.scale.z = CONFIG.chunkSize / 30; // 拉伸以匹配
                    chunkGroup.add(grid);

                    chunkGroup.position.z = -i * CONFIG.chunkSize;
                    this.scene.add(chunkGroup);
                    this.groundChunks.push(chunkGroup);

                    if(i > 3) this.spawnChunkContent(chunkGroup.position.z);
                }
            }

            reset() {
                this.objects.forEach(o => this.scene.remove(o.mesh));
                this.objects = [];
                for(let i=0; i<CONFIG.chunkCount; i++) {
                    this.groundChunks[i].position.z = -i * CONFIG.chunkSize;
                    if(i>3) this.spawnChunkContent(this.groundChunks[i].position.z);
                }
            }

            update(playerZ, magnetActive, playerPos) {
                const firstChunk = this.groundChunks[0];
                if (firstChunk.position.z > playerZ + CONFIG.chunkSize) {
                    let minZ = Infinity;
                    this.groundChunks.forEach(c => minZ = Math.min(minZ, c.position.z));
                    
                    firstChunk.position.z = minZ - CONFIG.chunkSize;
                    this.groundChunks.push(this.groundChunks.shift());
                    this.spawnChunkContent(firstChunk.position.z);
                }

                for (let i = this.objects.length - 1; i >= 0; i--) {
                    const obj = this.objects[i];
                    
                    if (obj.mesh.position.z > playerZ + 20) {
                        this.scene.remove(obj.mesh);
                        this.objects.splice(i, 1);
                        continue;
                    }

                    if (obj.type === 'coin') {
                        obj.mesh.rotation.x += 0.05;
                        if (magnetActive && obj.mesh.position.distanceTo(playerPos) < 20) {
                            obj.mesh.position.lerp(playerPos, 0.25);
                        }
                    } else if (obj.type === 'magnet' || obj.type === 'shield') {
                        obj.mesh.rotation.y += 0.05;
                        obj.mesh.position.y = 1 + Math.sin(Date.now()*0.005)*0.2;
                    }
                }
            }

            spawnChunkContent(zBase) {
                const segments = [0, -CONFIG.chunkSize/3, -CONFIG.chunkSize*2/3];
                segments.forEach(offset => {
                    const z = zBase + offset;
                    const rand = Math.random();
                    if (rand < 0.15) this.spawnItem(z);
                    else if (rand < 0.5) this.spawnCoinPattern(z);
                    else this.spawnObstacles(z);
                });
            }

            spawnItem(z) {
                const lane = Math.floor(Math.random()*3) - 1;
                const type = Math.random() > 0.5 ? 'magnet' : 'shield';
                const mesh = new THREE.Mesh(type === 'magnet' ? this.geoMagnet : this.geoShield, type === 'magnet' ? this.matMagnet : this.matShield);
                mesh.position.set(lane * CONFIG.laneWidth, 1, z);
                // 添加点光源让道具更亮
                // const light = new THREE.PointLight(type === 'magnet' ? CONFIG.colors.magnet : CONFIG.colors.shield, 1, 5);
                // mesh.add(light);
                this.scene.add(mesh);
                this.objects.push({ mesh, type, active: true });
            }

            spawnCoinPattern(z) {
                const pattern = Math.floor(Math.random() * 3);
                const lane = Math.floor(Math.random()*3) - 1;
                const x = lane * CONFIG.laneWidth;
                if (pattern === 0) {
                    for(let k=0; k<5; k++) this.createCoin(x, 1, z - k*2);
                } else if (pattern === 1) {
                    this.createCoin(x, 1, z); this.createCoin(x, 2, z-2); this.createCoin(x, 2, z-4); this.createCoin(x, 1, z-6);
                } else {
                    this.createCoin(-CONFIG.laneWidth, 1, z); this.createCoin(0, 1, z); this.createCoin(CONFIG.laneWidth, 1, z);
                }
            }

            createCoin(x, y, z) {
                const mesh = new THREE.Mesh(this.geoCoin, this.matCoin);
                mesh.position.set(x, y, z);
                this.scene.add(mesh);
                this.objects.push({ mesh, type: 'coin', active: true });
            }

            spawnObstacles(z) {
                const lanes = [-1, 0, 1].sort(()=>Math.random()-0.5);
                const count = Math.random() > 0.6 ? 2 : 1; 
                for(let i=0; i<count; i++) {
                    const lane = lanes[i];
                    const isHigh = Math.random() > 0.5;
                    const mesh = new THREE.Mesh(isHigh ? this.geoObsHigh : this.geoObsLow, isHigh ? this.matObsHigh : this.matObsLow);
                    const h = isHigh ? 3.0 : 0.9;
                    mesh.position.set(lane * CONFIG.laneWidth, h/2, z);
                    mesh.castShadow = true;
                    this.scene.add(mesh);
                    this.objects.push({ mesh, type: 'obstacle', active: true, box: new THREE.Vector3(2.5, h, 1) });
                }
            }

            checkCollisions(hero, callbacks) {
                const heroBox = hero.getHitbox();
                for (let i = 0; i < this.objects.length; i++) {
                    const obj = this.objects[i];
                    if (!obj.active || Math.abs(obj.mesh.position.z - hero.mesh.position.z) > 3) continue;

                    let hit = false;
                    if (['coin','magnet','shield'].includes(obj.type)) {
                        if (obj.mesh.position.distanceTo(hero.mesh.position) < 1.5) hit = true;
                    } else {
                        const obsBox = new THREE.Box3().setFromCenterAndSize(obj.mesh.position, obj.box);
                        if (heroBox.intersectsBox(obsBox)) hit = true;
                    }
                    if (hit) callbacks.onHit(obj, i);
                }
            }
        }

        // ==========================================
        // 4. 特效 & 游戏主控
        // ==========================================
        class ScreenShaker {
            constructor() { this.shake = 0; this.offset = new THREE.Vector3(); }
            trigger(val) { this.shake = val; }
            update(delta) {
                if(this.shake > 0) {
                    this.offset.set((Math.random()-0.5) * this.shake, (Math.random()-0.5) * this.shake, 0);
                    this.shake = Math.max(0, this.shake - delta*2);
                } else {
                    this.offset.set(0, 0, 0);
                }
            }
        }

        class ParticleSystem {
            constructor(scene) { this.scene = scene; this.pool = []; }
            spawn(pos, color, count=10) {
                const geo = new THREE.BoxGeometry(0.2, 0.2, 0.2);
                const mat = new THREE.MeshBasicMaterial({ color: color });
                for(let i=0; i<count; i++) {
                    const p = new THREE.Mesh(geo, mat);
                    p.position.copy(pos);
                    p.vel = new THREE.Vector3((Math.random()-0.5)*18, Math.random()*18, (Math.random()-0.5)*18);
                    p.life = 1.0;
                    this.scene.add(p);
                    this.pool.push(p);
                }
            }
            update(delta) {
                for(let i=this.pool.length-1; i>=0; i--) {
                    const p = this.pool[i];
                    p.position.addScaledVector(p.vel, delta);
                    p.vel.y -= 40 * delta; 
                    p.life -= delta * 1.5;
                    p.scale.setScalar(p.life);
                    p.rotation.x += delta*10;
                    if(p.life <= 0) { this.scene.remove(p); this.pool.splice(i, 1); }
                }
            }
        }

        class Game {
            constructor() {
                this.initThree();
                this.hero = new Hero(this.scene);
                this.world = new WorldManager(this.scene);
                this.particles = new ParticleSystem(this.scene);
                this.shaker = new ScreenShaker();

                this.state = 'MENU';
                this.hp = 0; this.score = 0; this.highScore = localStorage.getItem('cyber_highscore') || 0;
                this.speed = 0; this.magnetTimer = 0; this.hasShield = false;
                
                this.ui = {
                    hp: document.getElementById('hp-value'),
                    score: document.getElementById('score-value'),
                    best: document.getElementById('best-score'),
                    overlay: document.getElementById('overlay'),
                    title: document.getElementById('title-text'),
                    msg: document.getElementById('msg-text'),
                    menuStart: document.getElementById('start-menu'),
                    menuRestart: document.getElementById('restart-menu'),
                    buffShield: document.getElementById('buff-shield'),
                    buffMagnet: document.getElementById('buff-magnet')
                };
                this.ui.best.innerText = this.highScore;
                this.setupInputs();
                this.animate();
            }

            initThree() {
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(CONFIG.colors.sky);
                // 雾效颜色匹配背景
                this.scene.fog = new THREE.Fog(CONFIG.colors.fog, CONFIG.fogStart, CONFIG.fogEnd);
                
                this.camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 200);
                this.camera.position.set(0, 5, 10);
                
                this.renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                // 开启物理光照修正
                this.renderer.useLegacyLights = false; 
                document.getElementById('game-container').appendChild(this.renderer.domElement);

                // --- 高亮光照设置 ---
                // 1. 强环境光，消除死黑
                const ambi = new THREE.HemisphereLight(0xffffff, 0x444444, 1.2); 
                this.scene.add(ambi);

                // 2. 主光源 (太阳)
                this.sun = new THREE.DirectionalLight(0xffffff, 1.5);
                this.sun.position.set(15, 40, 20);
                this.sun.castShadow = true;
                this.sun.shadow.mapSize.set(2048, 2048);
                this.sun.shadow.camera.top = 50; this.sun.shadow.camera.bottom = -50;
                this.sun.shadow.camera.left = -30; this.sun.shadow.camera.right = 30;
                this.sun.shadow.bias = -0.001;
                this.scene.add(this.sun);
                
                // 3. 补光 (从正面打光，让物体更亮)
                const fillLight = new THREE.DirectionalLight(0xaaccff, 0.8);
                fillLight.position.set(0, 10, 10);
                this.scene.add(fillLight);

                window.addEventListener('resize', ()=> {
                    this.camera.aspect = window.innerWidth/window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });
            }

            showMenu() {
                this.state = 'MENU';
                this.ui.overlay.classList.remove('hidden');
                this.ui.title.innerText = "CYBER RUN";
                this.ui.msg.innerHTML = "NEON OVERDRIVE<br>SYSTEM READY";
                this.ui.menuStart.classList.remove('hidden');
                this.ui.menuRestart.classList.add('hidden');
            }

            start(hpMode) {
                this.state = 'PLAYING';
                this.lastHpMode = hpMode;
                this.hp = hpMode;
                this.score = 0;
                this.speed = CONFIG.physics.speedBase;
                this.magnetTimer = 0;
                this.hasShield = false;
                this.hero.reset();
                this.world.reset();
                this.updateUI();
                this.ui.overlay.classList.add('hidden');
            }

            gameOver() {
                this.state = 'GAMEOVER';
                this.hero.isDead = true;
                this.hero.mesh.rotation.x = -Math.PI/2;
                this.hero.mesh.position.y = 0.5;
                this.shaker.trigger(0.5);
                if (this.score > this.highScore) {
                    this.highScore = Math.floor(this.score);
                    localStorage.setItem('cyber_highscore', this.highScore);
                    this.ui.best.innerText = this.highScore;
                }
                setTimeout(() => {
                    this.ui.overlay.classList.remove('hidden');
                    this.ui.title.innerText = "CRITICAL FAILURE";
                    this.ui.msg.innerText = `最终得分: ${Math.floor(this.score)}`;
                    this.ui.menuStart.classList.add('hidden');
                    this.ui.menuRestart.classList.remove('hidden');
                }, 1000);
            }

            update(delta) {
                if (this.state !== 'PLAYING') return;

                if (this.speed < CONFIG.physics.speedMax) this.speed += delta * 0.5;
                const moveDist = this.speed * delta;
                this.hero.mesh.position.z -= moveDist;

                if (this.magnetTimer > 0) this.magnetTimer -= delta;

                this.hero.update(delta, this.speed);
                this.world.update(this.hero.mesh.position.z, this.magnetTimer > 0, this.hero.mesh.position);
                this.particles.update(delta);
                this.shaker.update(delta);

                this.world.checkCollisions(this.hero, {
                    onHit: (obj, index) => this.handleCollision(obj, index)
                });

                this.score += moveDist * 0.1;
                this.updateUI();

                // 摄像机逻辑 (带修正)
                const targetZ = this.hero.mesh.position.z + 10;
                const targetX = this.hero.mesh.position.x * 0.6;
                const baseY = 5; 

                this.camera.position.x = THREE.MathUtils.lerp(this.camera.position.x, targetX, 5 * delta) + this.shaker.offset.x;
                this.camera.position.y = baseY + this.shaker.offset.y;
                this.camera.position.z = targetZ;
                this.camera.lookAt(this.camera.position.x * 0.5, 2, this.camera.position.z - 20);
                
                this.sun.position.z = this.hero.mesh.position.z + 20;
                this.sun.target.position.z = this.hero.mesh.position.z;
                this.sun.target.updateMatrixWorld();
            }

            handleCollision(obj, index) {
                obj.active = false;
                this.scene.remove(obj.mesh);

                if (obj.type === 'coin') {
                    this.score += 50;
                    this.particles.spawn(obj.mesh.position, CONFIG.colors.coin, 5);
                } 
                else if (obj.type === 'magnet') {
                    this.magnetTimer = 10;
                    this.particles.spawn(obj.mesh.position, CONFIG.colors.magnet, 15);
                } 
                else if (obj.type === 'shield') {
                    this.hasShield = true;
                    this.hero.setShield(true);
                    this.particles.spawn(obj.mesh.position, CONFIG.colors.shield, 15);
                }
                else if (obj.type === 'obstacle') {
                    if (this.hasShield) {
                        this.hasShield = false;
                        this.hero.setShield(false);
                        this.particles.spawn(obj.mesh.position, 0x00f2ff, 20);
                        this.shaker.trigger(0.5);
                    } else {
                        if (this.hp <= 9999) this.hp--;
                        this.particles.spawn(obj.mesh.position, 0xff0055, 20);
                        this.shaker.trigger(1.2);
                        this.hero.takeDamage();
                        if (this.hp <= 0) this.gameOver();
                    }
                }
            }

            updateUI() {
                this.ui.score.innerText = Math.floor(this.score).toString().padStart(6, '0');
                this.ui.hp.innerText = (this.hp > 9999) ? "INF" : this.hp;
                this.ui.buffMagnet.style.display = this.magnetTimer > 0 ? 'block' : 'none';
                this.ui.buffShield.style.display = this.hasShield ? 'block' : 'none';
                if (this.magnetTimer > 0) this.ui.buffMagnet.innerText = `MAGNET ${Math.ceil(this.magnetTimer)}s`;
            }

            animate() {
                requestAnimationFrame(() => this.animate());
                const delta = Math.min(this.clock.getDelta(), 0.1);
                this.update(delta);
                this.renderer.render(this.scene, this.camera);
            }

            setupInputs() {
                this.clock = new THREE.Clock();
                const handleDir = (dir) => this.hero.changeLane(dir);
                document.addEventListener('keydown', (e) => {
                    if (this.state !== 'PLAYING') return;
                    if (e.key === 'ArrowLeft' || e.key === 'a') handleDir(-1);
                    if (e.key === 'ArrowRight' || e.key === 'd') handleDir(1);
                    if (e.key === 'ArrowUp' || e.key === 'w' || e.key === ' ') this.hero.jump();
                    if (e.key === 'ArrowDown' || e.key === 's') this.hero.duck();
                });
                let sx=0, sy=0;
                document.addEventListener('touchstart', e => { sx = e.touches[0].clientX; sy = e.touches[0].clientY; }, {passive: false});
                document.addEventListener('touchend', e => {
                    if (this.state !== 'PLAYING') return;
                    const dx = e.changedTouches[0].clientX - sx;
                    const dy = e.changedTouches[0].clientY - sy;
                    if (Math.abs(dx) > Math.abs(dy)) {
                        if (Math.abs(dx) > 30) handleDir(dx > 0 ? 1 : -1);
                    } else {
                        if (Math.abs(dy) > 30) { dy < 0 ? this.hero.jump() : this.hero.duck(); }
                    }
                }, {passive: false});
                document.addEventListener('touchmove', e => e.preventDefault(), {passive: false});
            }
        }

        const gameInstance = new Game();
    </script>
</body>
</html>
